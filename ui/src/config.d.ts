/* eslint-disable */
/**
 * This file was automatically generated by json-schema-to-typescript.
 * DO NOT MODIFY IT BY HAND. Instead, modify the source JSONSchema file,
 * and run json-schema-to-typescript to regenerate this file.
 */

export type StringBoolFloat = string | number | boolean;
export type RawLoggingLevel = string | string[];
export type LoggingFormat = "text" | "json";
export type LocalListenerProtocol = "HTTP" | "HTTPS" | "TLS" | "TCP" | "HBONE";
export type TLSVersion = "TLS_V1_0" | "TLS_V1_1" | "TLS_V1_2" | "TLS_V1_3";
export type HeaderValueMatch =
  | {
      exact: string;
    }
  | {
      regex: string;
    };
export type PathMatch =
  | {
      exact: string;
    }
  | {
      pathPrefix: string;
    }
  | {
      /**
       * @minItems 2
       * @maxItems 2
       */
      regex: [unknown, unknown];
    };
export type QueryValueMatch =
  | {
      exact: string;
    }
  | {
      regex: string;
    };
export type HostRedirect =
  | ("auto" | "none")
  | {
      full: string;
    }
  | {
      host: string;
    }
  | {
      port: number;
    };
export type PathRedirect =
  | {
      full: string;
    }
  | {
      prefix: string;
    };
export type SimpleLocalBackend =
  | "invalid"
  | {
      service: {
        name: NamespacedHostname;
        port: number;
      };
    }
  | {
      /**
       * Hostname or IP address
       */
      host: string;
    }
  | {
      /**
       * Explicit backend reference. Backend must be defined in the top level backends list
       */
      backend: string;
    };
export type Bytes = number[] | string;
export type McpIDP =
  | {
      auth0: {};
    }
  | {
      keycloak: {};
    };
export type FileInlineOrRemote =
  | {
      file: string;
      [k: string]: unknown;
    }
  | string
  | {
      url: string;
      [k: string]: unknown;
    };
export type RequestGuard = {
  rejection?: RequestRejection;
  [k: string]: unknown;
} & RequestGuard1;
export type Bytes1 = number[] | string;
export type RequestGuard1 =
  | {
      regex: RegexRules;
      [k: string]: unknown;
    }
  | {
      webhook: Webhook;
      [k: string]: unknown;
    }
  | {
      openAIModeration: Moderation;
      [k: string]: unknown;
    }
  | {
      bedrockGuardrails: BedrockGuardrails;
      [k: string]: unknown;
    }
  | {
      googleModelArmor: GoogleModelArmor;
      [k: string]: unknown;
    };
export type RegexRule =
  | {
      builtin: Builtin;
    }
  | {
      pattern: string;
    };
export type Builtin = "ssn" | "creditCard" | "phoneNumber" | "email" | "caSin";
export type BackendAuth =
  | {
      passthrough: {};
    }
  | {
      key: FileOrInline;
    }
  | {
      gcp: GcpAuth;
    }
  | {
      aws: AwsAuth;
    }
  | {
      azure: AzureAuth;
    };
export type FileOrInline =
  | {
      file: string;
      [k: string]: unknown;
    }
  | string;
export type GcpAuth =
  | {
      type: IdToken;
      /**
       * Audience for the token. If not set, the destination host will be used.
       */
      audience?: string | null;
    }
  | {
      type?: AccessToken | null;
    };
export type IdToken = "idToken";
export type AccessToken = "accessToken";
export type AwsAuth =
  | {
      accessKeyId: string;
      secretAccessKey: string;
      region?: string | null;
      sessionToken?: string | null;
    }
  | {};
export type AzureAuth =
  | {
      explicitConfig:
        | {
            clientSecret: {
              tenant_id: string;
              client_id: string;
              client_secret: string;
            };
            [k: string]: unknown;
          }
        | {
            managedIdentity: {
              userAssignedIdentity?: AzureUserAssignedIdentity | null;
            };
            [k: string]: unknown;
          }
        | {
            workloadIdentity: {};
            [k: string]: unknown;
          };
    }
  | {
      developerImplicit: {};
    };
export type AzureUserAssignedIdentity =
  | {
      clientId: string;
    }
  | {
      objectId: string;
    }
  | {
      resourceId: string;
    };
export type ResponseGuard = {
  rejection?: RequestRejection1;
  [k: string]: unknown;
} & ResponseGuard1;
export type ResponseGuard1 =
  | {
      regex: RegexRules;
      [k: string]: unknown;
    }
  | {
      webhook: Webhook;
      [k: string]: unknown;
    }
  | {
      bedrockGuardrails: BedrockGuardrails;
      [k: string]: unknown;
    }
  | {
      googleModelArmor: GoogleModelArmor;
      [k: string]: unknown;
    };
export type RouteType =
  | "completions"
  | "messages"
  | "models"
  | "passthrough"
  | "responses"
  | "embeddings"
  | "realtime"
  | "anthropicTokenCount";
export type RemoteRateLimit = {
  domain: string;
  descriptors: DescriptorSet;
  /**
   * Timeout for the request
   */
  timeout?: string | null;
  [k: string]: unknown;
} & RemoteRateLimit1;
export type DescriptorSet = DescriptorEntry[];
export type RemoteRateLimit1 =
  | "invalid"
  | {
      service: {
        name: NamespacedHostname;
        port: number;
      };
      [k: string]: unknown;
    }
  | {
      /**
       * Hostname or IP address
       */
      host: string;
      [k: string]: unknown;
    }
  | {
      /**
       * Explicit backend reference. Backend must be defined in the top level backends list
       */
      backend: string;
      [k: string]: unknown;
    };
export type LocalJwtConfig =
  | {
      mode?: "strict" | "optional" | "permissive";
      providers: ProviderConfig[];
    }
  | {
      mode?: "strict" | "optional" | "permissive";
      issuer: string;
      audiences?: string[] | null;
      jwks: FileInlineOrRemote;
    };
export type APIKey = string;
export type ExtAuthz = {
  /**
   * The ext_authz protocol to use. Unless you need to integrate with an HTTP-only server, gRPC is recommended.
   */
  protocol?:
    | {
        grpc: {
          /**
           * Additional context to send to the authorization service.
           * This maps to the `context_extensions` field of the request, and only allows static values.
           */
          context?: {
            [k: string]: string;
          } | null;
          /**
           * Additional metadata to send to the authorization service.
           * This maps to the `metadata_context.filter_metadata` field of the request, and allows dynamic CEL expressions.
           * If unset, by default the `envoy.filters.http.jwt_authn` key is set if the JWT policy is used as well, for compatibility.
           */
          metadata?: {
            [k: string]: Expression;
          } | null;
        };
      }
    | {
        http: {
          path?: Expression | null;
          /**
           * When using the HTTP protocol, and the server returns unauthorized, redirect to the URL resolved by
           * the provided expression rather than directly returning the error.
           */
          redirect?: Expression | null;
          /**
           * Specific headers from the authorization response will be copied into the request to the backend.
           */
          includeResponseHeaders?: string[];
          /**
           * Specific headers to add in the authorization request (empty = all headers), based on the expression
           */
          addRequestHeaders?: {
            [k: string]: Expression;
          };
          /**
           * Metadata to include under the `extauthz` variable, based on the authorization response.
           */
          metadata?: {
            [k: string]: Expression;
          };
        };
      };
  /**
   * Behavior when the authorization service is unavailable or returns an error
   */
  failureMode?:
    | ("allow" | "deny")
    | {
        denyWithStatus: number;
      };
  /**
   * Specific headers to include in the authorization request.
   * If unset, the gRPC protocol sends all request headers. The HTTP protocol sends only 'Authorization'.
   */
  includeRequestHeaders?: HeaderOrPseudo[];
  /**
   * Options for including the request body in the authorization request
   */
  includeRequestBody?: BodyOptions | null;
  /**
   * Timeout for the authorization request (default: 200ms)
   */
  timeout?: string | null;
  [k: string]: unknown;
} & ExtAuthz1;
export type Expression = string;
export type HeaderOrPseudo = string;
export type ExtAuthz1 =
  | "invalid"
  | {
      service: {
        name: NamespacedHostname;
        port: number;
      };
      [k: string]: unknown;
    }
  | {
      /**
       * Hostname or IP address
       */
      host: string;
      [k: string]: unknown;
    }
  | {
      /**
       * Explicit backend reference. Backend must be defined in the top level backends list
       */
      backend: string;
      [k: string]: unknown;
    };
export type ExtProc = {
  /**
   * Behavior when the ext_proc service is unavailable or returns an error
   */
  failureMode?: "failClosed" | "failOpen";
  /**
   * Additional metadata to send to the external processing service.
   * Maps to the `metadata_context.filter_metadata` field in ProcessingRequest, and allows dynamic CEL expressions.
   */
  metadataContext?: {
    [k: string]: {
      [k: string]: Expression;
    };
  } | null;
  /**
   * Maps to the request `attributes` field in ProcessingRequest, and allows dynamic CEL expressions.
   */
  requestAttributes?: {
    [k: string]: Expression;
  } | null;
  /**
   * Maps to the response `attributes` field in ProcessingRequest, and allows dynamic CEL expressions.
   */
  responseAttributes?: {
    [k: string]: Expression;
  } | null;
  [k: string]: unknown;
} & ExtProc1;
export type ExtProc1 =
  | "invalid"
  | {
      service: {
        name: NamespacedHostname;
        port: number;
      };
      [k: string]: unknown;
    }
  | {
      /**
       * Hostname or IP address
       */
      host: string;
      [k: string]: unknown;
    }
  | {
      /**
       * Explicit backend reference. Backend must be defined in the top level backends list
       */
      backend: string;
      [k: string]: unknown;
    };
export type LocalRouteBackend = {
  weight?: number;
  policies?: LocalBackendPolicies | null;
  [k: string]: unknown;
} & LocalRouteBackend1;
export type LocalRouteBackend1 =
  | "invalid"
  | {
      service: {
        name: NamespacedHostname;
        port: number;
      };
      [k: string]: unknown;
    }
  | {
      host: string;
      [k: string]: unknown;
    }
  | {
      dynamic: {};
      [k: string]: unknown;
    }
  | {
      mcp: LocalMcpBackend;
      [k: string]: unknown;
    }
  | {
      ai: LocalAIBackend;
      [k: string]: unknown;
    };
export type LocalMcpTarget = {
  name: string;
  policies?: LocalBackendPolicies | null;
  [k: string]: unknown;
} & LocalMcpTarget1;
export type LocalMcpTarget1 =
  | {
      sse: {
        host: string;
        port?: number | null;
        path?: string | null;
      };
      [k: string]: unknown;
    }
  | {
      mcp: {
        host: string;
        port?: number | null;
        path?: string | null;
      };
      [k: string]: unknown;
    }
  | {
      stdio: {
        cmd: string;
        args?: string[];
        env?: {
          [k: string]: string;
        };
      };
      [k: string]: unknown;
    }
  | {
      openapi: {
        host: string;
        port?: number | null;
        path?: string | null;
        schema: unknown;
      };
      [k: string]: unknown;
    };
export type McpStatefulMode = "stateless" | "stateful";
export type McpPrefixMode = "always" | "conditional";
export type LocalAIBackend =
  | LocalNamedAIProvider
  | {
      groups: LocalAIProviders[];
    };
export type AIProvider =
  | {
      openAI: Provider;
    }
  | {
      gemini: Provider2;
    }
  | {
      vertex: Provider3;
    }
  | {
      anthropic: Provider4;
    }
  | {
      bedrock: Provider5;
    }
  | {
      azureOpenAI: Provider6;
    };
export type LocalTCPRouteBackend = {
  weight?: number;
  policies?: LocalTCPBackendPolicies | null;
  [k: string]: unknown;
} & LocalTCPRouteBackend1;
export type LocalTCPRouteBackend1 =
  | "invalid"
  | {
      service: {
        name: NamespacedHostname;
        port: number;
      };
      [k: string]: unknown;
    }
  | {
      /**
       * Hostname or IP address
       */
      host: string;
      [k: string]: unknown;
    }
  | {
      /**
       * Explicit backend reference. Backend must be defined in the top level backends list
       */
      backend: string;
      [k: string]: unknown;
    };
/**
 * Configuration for dynamic tracing policy
 */
export type TracingConfig = {
  attributes?: OrderedStringMap_Expression;
  resources?: OrderedStringMap_Expression1;
  /**
   * Attribute keys to remove from the emitted span attributes.
   *
   * This is applied before `attributes` are evaluated/added, so it can be used to drop
   * default attributes or avoid duplication.
   */
  remove?: string[];
  /**
   * Optional per-policy override for random sampling. If set, overrides global config for
   * requests that use this frontend policy.
   */
  randomSampling?: Expression | null;
  /**
   * Optional per-policy override for client sampling. If set, overrides global config for
   * requests that use this frontend policy.
   */
  clientSampling?: Expression | null;
  path?: string;
  protocol?: "http" | "grpc";
  [k: string]: unknown;
} & TracingConfig1;
export type TracingConfig1 =
  | "invalid"
  | {
      service: {
        name: NamespacedHostname;
        port: number;
      };
      [k: string]: unknown;
    }
  | {
      /**
       * Hostname or IP address
       */
      host: string;
      [k: string]: unknown;
    }
  | {
      /**
       * Explicit backend reference. Backend must be defined in the top level backends list
       */
      backend: string;
      [k: string]: unknown;
    };
export type PolicyTarget =
  | {
      gateway: ListenerTarget;
    }
  | {
      route: RouteName;
    }
  | {
      backend: BackendTarget;
    };
export type BackendTarget =
  | "invalid"
  | {
      backend: {
        name: string;
        namespace: string;
        section?: string | null;
      };
    }
  | {
      service: {
        hostname: string;
        namespace: string;
        port?: number | null;
      };
    };

export interface LocalConfig {
  config?: RawConfig;
  binds?: LocalBind[];
  frontendPolicies?: LocalFrontendPolicies;
  /**
   * policies defines additional policies that can be attached to various other configurations.
   * This is an advanced feature; users should typically use the inline `policies` field under route/gateway.
   */
  policies?: LocalPolicy[];
  workloads?: {
    [k: string]: unknown;
  };
  services?: {
    [k: string]: unknown;
  };
  backends?: FullLocalBackend[];
  llm?: LocalLLMConfig | null;
  mcp?: LocalSimpleMcpConfig | null;
}
export interface RawConfig {
  enableIpv6?: boolean | null;
  /**
   * Local XDS path. If not specified, the current configuration file will be used.
   */
  localXdsPath?: string | null;
  caAddress?: string | null;
  caAuthToken?: string | null;
  xdsAddress?: string | null;
  xdsAuthToken?: string | null;
  namespace?: string | null;
  gateway?: string | null;
  trustDomain?: string | null;
  serviceAccount?: string | null;
  clusterId?: string | null;
  network?: string | null;
  /**
   * Admin UI address in the format "ip:port"
   */
  adminAddr?: string | null;
  /**
   * Stats/metrics server address in the format "ip:port"
   */
  statsAddr?: string | null;
  /**
   * Readiness probe server address in the format "ip:port"
   */
  readinessAddr?: string | null;
  /**
   * Configuration for stateful session management
   */
  session?: RawSession | null;
  connectionTerminationDeadline?: string | null;
  connectionMinTerminationDeadline?: string | null;
  workerThreads?: string | null;
  tracing?: RawTracing | null;
  logging?: RawLogging | null;
  metrics?: RawMetrics | null;
  backend?: BackendConfig;
  hbone?: RawHBONE | null;
}
export interface RawSession {
  /**
   * The signing key to be used. If not set, sessions will not be encrypted.
   * For example, generated via `openssl rand -hex 32`.
   */
  key: string;
}
export interface RawTracing {
  otlpEndpoint: string;
  headers?: {
    [k: string]: string;
  };
  otlpProtocol?: "grpc" | "http";
  fields?: RawLoggingFields | null;
  /**
   * Expression to determine the amount of *random sampling*.
   * Random sampling will initiate a new trace span if the incoming request does not have a trace already.
   * This should evaluate to either a float between 0.0-1.0 (0-100%) or true/false.
   * This defaults to 'false'.
   */
  randomSampling?: StringBoolFloat | null;
  /**
   * Expression to determine the amount of *client sampling*.
   * Client sampling determines whether to initiate a new trace span if the incoming request does have a trace already.
   * This should evaluate to either a float between 0.0-1.0 (0-100%) or true/false.
   * This defaults to 'true'.
   */
  clientSampling?: StringBoolFloat | null;
  /**
   * OTLP path. Default is /v1/traces
   */
  path?: string | null;
}
export interface RawLoggingFields {
  remove?: string[];
  add?: {
    [k: string]: string;
  };
}
export interface RawLogging {
  filter?: string | null;
  fields?: RawLoggingFields | null;
  level?: RawLoggingLevel | null;
  format?: LoggingFormat | null;
}
export interface RawMetrics {
  remove?: string[];
  fields?: RawMetricFields | null;
}
export interface RawMetricFields {
  add?: {
    [k: string]: string;
  };
}
export interface BackendConfig {
  keepalives?: KeepaliveConfig;
  connectTimeout?: string;
  /**
   * The maximum duration to keep an idle connection alive.
   */
  poolIdleTimeout?: string;
  /**
   * The maximum number of connections allowed in the pool, per hostname. If set, this will limit
   * the total number of connections kept alive to any given host.
   * Note: excess connections will still be created, they will just not remain idle.
   * If unset, there is no limit
   */
  poolMaxSize?: number | null;
}
export interface KeepaliveConfig {
  enabled?: boolean;
  time?: string;
  interval?: string;
  retries?: number;
}
export interface RawHBONE {
  windowSize?: number | null;
  connectionWindowSize?: number | null;
  frameSize?: number | null;
  poolMaxStreamsPerConn?: number | null;
  poolUnusedReleaseTimeout?: string | null;
}
export interface LocalBind {
  port: number;
  listeners: LocalListener[];
  tunnelProtocol?: "direct" | "hboneWaypoint" | "hboneGateway" | "proxy";
}
export interface LocalListener {
  name?: string | null;
  namespace?: string | null;
  /**
   * Can be a wildcard
   */
  hostname?: string | null;
  protocol?: LocalListenerProtocol;
  tls?: LocalTLSServerConfig | null;
  routes?: LocalRoute[] | null;
  tcpRoutes?: LocalTCPRoute[] | null;
  policies?: LocalGatewayPolicy | null;
}
export interface LocalTLSServerConfig {
  cert: string;
  key: string;
  root?: string | null;
  /**
   * Optional cipher suite allowlist (order is preserved).
   */
  cipherSuites?: string[] | null;
  /**
   * Minimum supported TLS version (only TLS 1.2 and 1.3 are supported).
   */
  minTLSVersion?: TLSVersion | null;
  /**
   * Maximum supported TLS version (only TLS 1.2 and 1.3 are supported).
   */
  maxTLSVersion?: TLSVersion | null;
}
export interface LocalRoute {
  name?: string | null;
  namespace?: string | null;
  ruleName?: string | null;
  /**
   * Can be a wildcard
   */
  hostnames?: string[];
  matches?: RouteMatch[];
  policies?: FilterOrPolicy | null;
  backends?: LocalRouteBackend[];
}
export interface RouteMatch {
  headers?: HeaderMatch[];
  path: PathMatch;
  method?: string;
  query?: QueryMatch[];
}
export interface HeaderMatch {
  name: string;
  value: HeaderValueMatch;
}
export interface QueryMatch {
  name: string;
  value: QueryValueMatch;
}
export interface FilterOrPolicy {
  /**
   * Headers to be modified in the request.
   */
  requestHeaderModifier?: HeaderModifier | null;
  /**
   * Headers to be modified in the response.
   */
  responseHeaderModifier?: HeaderModifier | null;
  /**
   * Directly respond to the request with a redirect.
   */
  requestRedirect?: RequestRedirect | null;
  /**
   * Modify the URL path or authority.
   */
  urlRewrite?: UrlRewrite | null;
  /**
   * Mirror incoming requests to another destination.
   */
  requestMirror?: RequestMirror | null;
  /**
   * Directly respond to the request with a static response.
   */
  directResponse?: DirectResponse | null;
  /**
   * Handle CORS preflight requests and append configured CORS headers to applicable requests.
   */
  cors?: CorsSerde | null;
  /**
   * Authorization policies for MCP access.
   */
  mcpAuthorization?: RuleSet | null;
  /**
   * Authorization policies for HTTP access.
   */
  authorization?: RuleSet | null;
  /**
   * Authentication for MCP clients.
   */
  mcpAuthentication?: LocalMcpAuthentication | null;
  /**
   * Mark this traffic as A2A to enable A2A processing and telemetry.
   */
  a2a?: A2APolicy | null;
  /**
   * Mark this as LLM traffic to enable LLM processing.
   */
  ai?: Policy | null;
  /**
   * Send TLS to the backend.
   */
  backendTLS?: LocalBackendTLS | null;
  /**
   * Authenticate to the backend.
   */
  backendAuth?: BackendAuth | null;
  /**
   * Rate limit incoming requests. State is kept local.
   */
  localRateLimit?: RateLimitSpec[];
  /**
   * Rate limit incoming requests. State is managed by a remote server.
   */
  remoteRateLimit?: RemoteRateLimit | null;
  /**
   * Authenticate incoming JWT requests.
   */
  jwtAuth?: LocalJwtConfig | null;
  /**
   * Authenticate incoming requests using Basic Authentication with htpasswd.
   */
  basicAuth?: LocalBasicAuth | null;
  /**
   * Authenticate incoming requests using API Keys
   */
  apiKey?: LocalAPIKeys | null;
  /**
   * Authenticate incoming requests by calling an external authorization server.
   */
  extAuthz?: ExtAuthz | null;
  /**
   * Extend agentgateway with an external processor
   */
  extProc?: ExtProc | null;
  /**
   * Modify requests and responses
   */
  transformations?: LocalTransformationConfig | null;
  /**
   * Handle CSRF protection by validating request origins against configured allowed origins.
   */
  csrf?: Csrf | null;
  /**
   * Timeout requests that exceed the configured duration.
   */
  timeout?: Policy2 | null;
  /**
   * Retry matching requests.
   */
  retry?: Policy3 | null;
}
export interface HeaderModifier {
  add?: {
    [k: string]: string;
  };
  set?: {
    [k: string]: string;
  };
  remove?: string[];
}
export interface RequestRedirect {
  scheme?: string | null;
  authority?: HostRedirect | null;
  path?: PathRedirect | null;
  status?: number | null;
}
export interface UrlRewrite {
  authority?: HostRedirect | null;
  path?: PathRedirect | null;
}
export interface RequestMirror {
  backend: SimpleLocalBackend;
  percentage: number;
}
export interface NamespacedHostname {
  namespace: string;
  hostname: string;
  [k: string]: unknown;
}
export interface DirectResponse {
  body: Bytes;
  status: number;
}
export interface CorsSerde {
  allowCredentials?: boolean;
  allowHeaders?: string[];
  allowMethods?: string[];
  allowOrigins?: string[];
  exposeHeaders?: string[];
  maxAge?: string | null;
}
export interface RuleSet {
  rules: string[];
}
export interface LocalMcpAuthentication {
  issuer: string;
  audiences: string[];
  provider?: McpIDP | null;
  resourceMetadata: ResourceMetadata;
  jwks: FileInlineOrRemote;
  mode?: "strict" | "optional" | "permissive";
}
export interface ResourceMetadata {
  [k: string]: unknown;
}
export interface A2APolicy {}
export interface Policy {
  promptGuard?: PromptGuard | null;
  defaults?: {
    [k: string]: unknown;
  } | null;
  overrides?: {
    [k: string]: unknown;
  } | null;
  prompts?: PromptEnrichment | null;
  modelAliases?: {
    [k: string]: string;
  };
  promptCaching?: PromptCachingConfig | null;
  routes?: {
    [k: string]: RouteType;
  };
}
export interface PromptGuard {
  request?: RequestGuard[];
  response?: ResponseGuard[];
}
export interface RequestRejection {
  body?: Bytes1;
  status?: number;
  /**
   * Optional headers to add, set, or remove from the rejection response
   */
  headers?: HeaderModifier | null;
}
export interface RegexRules {
  action?: "mask" | "reject";
  rules: RegexRule[];
}
export interface Webhook {
  target: SimpleLocalBackend;
  forwardHeaderMatches?: HeaderMatch[];
}
export interface Moderation {
  /**
   * Model to use. Defaults to `omni-moderation-latest`
   */
  model?: string | null;
  policies: LocalBackendPolicies;
}
export interface LocalBackendPolicies {
  /**
   * Headers to be modified in the request.
   */
  requestHeaderModifier?: HeaderModifier | null;
  /**
   * Headers to be modified in the response.
   */
  responseHeaderModifier?: HeaderModifier | null;
  /**
   * Directly respond to the request with a redirect.
   */
  requestRedirect?: RequestRedirect | null;
  /**
   * Authorization policies for MCP access.
   */
  mcpAuthorization?: RuleSet | null;
  /**
   * Mark this traffic as A2A to enable A2A processing and telemetry.
   */
  a2a?: A2APolicy | null;
  /**
   * Mark this as LLM traffic to enable LLM processing.
   */
  ai?: Policy | null;
  /**
   * Send TLS to the backend.
   */
  backendTLS?: LocalBackendTLS | null;
  /**
   * Authenticate to the backend.
   */
  backendAuth?: BackendAuth | null;
  /**
   * Specify HTTP settings for the backend
   */
  http?: HTTP | null;
  /**
   * Specify TCP settings for the backend
   */
  tcp?: TCP | null;
}
export interface LocalBackendTLS {
  cert?: string | null;
  key?: string | null;
  root?: string | null;
  hostname?: string | null;
  insecure?: boolean;
  insecureHost?: boolean;
  alpn?: string[] | null;
  subjectAltNames?: string[] | null;
}
export interface HTTP {
  version?: string | null;
  requestTimeout?: string | null;
}
export interface TCP {
  keepalives: KeepaliveConfig1;
  connectTimeout: Duration;
}
export interface KeepaliveConfig1 {
  enabled?: boolean;
  time?: string;
  interval?: string;
  retries?: number;
}
export interface Duration {
  secs: number;
  nanos: number;
  [k: string]: unknown;
}
/**
 * Configuration for AWS Bedrock Guardrails integration.
 */
export interface BedrockGuardrails {
  /**
   * The unique identifier of the guardrail
   */
  guardrailIdentifier: string;
  /**
   * The version of the guardrail
   */
  guardrailVersion: string;
  /**
   * AWS region where the guardrail is deployed
   */
  region: string;
  /**
   * Backend policies for AWS authentication (optional, defaults to implicit AWS auth)
   */
  policies?: LocalBackendPolicies | null;
}
/**
 * Configuration for Google Cloud Model Armor integration.
 */
export interface GoogleModelArmor {
  /**
   * The template ID for the Model Armor configuration
   */
  templateId: string;
  /**
   * The GCP project ID
   */
  projectId: string;
  /**
   * The GCP region (default: us-central1)
   */
  location?: string | null;
  /**
   * Backend policies for GCP authentication (optional, defaults to implicit GCP auth)
   */
  policies?: LocalBackendPolicies | null;
}
export interface RequestRejection1 {
  body?: Bytes1;
  status?: number;
  /**
   * Optional headers to add, set, or remove from the rejection response
   */
  headers?: HeaderModifier | null;
}
export interface PromptEnrichment {
  append?: SimpleChatCompletionMessage[];
  prepend?: SimpleChatCompletionMessage[];
}
/**
 * SimpleChatCompletionMessage is a simplified chat message
 */
export interface SimpleChatCompletionMessage {
  role: string;
  content: string;
}
export interface PromptCachingConfig {
  cacheSystem?: boolean;
  cacheMessages?: boolean;
  cacheTools?: boolean;
  minTokens?: number | null;
}
export interface RateLimitSpec {
  maxTokens?: number;
  tokensPerFill?: number;
  fillInterval: string;
  type?: "requests" | "tokens";
}
export interface DescriptorEntry {
  entries: KV[];
  type?: "requests" | "tokens";
}
export interface KV {
  key: string;
  value: string;
  [k: string]: unknown;
}
export interface ProviderConfig {
  issuer: string;
  audiences?: string[] | null;
  jwks: FileInlineOrRemote;
}
export interface LocalBasicAuth {
  /**
   * .htpasswd file contents/reference
   */
  htpasswd:
    | {
        file: string;
        [k: string]: unknown;
      }
    | string;
  /**
   * Realm name for the WWW-Authenticate header
   */
  realm?: string | null;
  /**
   * Validation mode for basic authentication
   */
  mode?: "strict" | "optional";
}
export interface LocalAPIKeys {
  /**
   * List of API keys
   */
  keys: LocalAPIKey[];
  /**
   * Validation mode for API keys
   */
  mode?: "strict" | "optional";
}
export interface LocalAPIKey {
  key: APIKey;
  metadata?: unknown;
}
export interface BodyOptions {
  /**
   * Maximum size of request body to buffer (default: 8192)
   */
  maxRequestBytes?: number;
  /**
   * If true, send partial body when max_request_bytes is reached
   */
  allowPartialMessage?: boolean;
  /**
   * If true, pack body as raw bytes in gRPC
   */
  packAsBytes?: boolean;
}
export interface LocalTransformationConfig {
  request?: LocalTransform | null;
  response?: LocalTransform | null;
}
export interface LocalTransform {
  add?: {
    [k: string]: string;
  };
  set?: {
    [k: string]: string;
  };
  remove?: string[];
  body?: string | null;
}
export interface Csrf {
  additionalOrigins?: string[];
}
export interface Policy2 {
  requestTimeout?: string | null;
  backendRequestTimeout?: string | null;
}
export interface Policy3 {
  attempts?: number;
  backoff?: string | null;
  codes: number[];
}
export interface LocalMcpBackend {
  targets: LocalMcpTarget[];
  statefulMode?: McpStatefulMode;
  prefixMode?: McpPrefixMode | null;
}
export interface LocalNamedAIProvider {
  name: string;
  provider: AIProvider;
  hostOverride?: string | null;
  pathOverride?: string | null;
  /**
   * Whether to tokenize on the request flow. This enables us to do more accurate rate limits,
   * since we know (part of) the cost of the request upfront.
   * This comes with the cost of an expensive operation.
   */
  tokenize?: boolean;
  policies?: LocalBackendPolicies | null;
}
export interface Provider {
  model?: string | null;
}
export interface Provider2 {
  model?: string | null;
  [k: string]: unknown;
}
export interface Provider3 {
  model?: string | null;
  region?: string | null;
  projectId: string;
}
export interface Provider4 {
  model?: string | null;
}
export interface Provider5 {
  model?: string | null;
  region: string;
  guardrailIdentifier?: string | null;
  guardrailVersion?: string | null;
  [k: string]: unknown;
}
export interface Provider6 {
  model?: string | null;
  host: string;
  apiVersion?: string | null;
}
export interface LocalAIProviders {
  providers: LocalNamedAIProvider[];
}
export interface LocalTCPRoute {
  name?: string | null;
  namespace?: string | null;
  ruleName?: string | null;
  /**
   * Can be a wildcard
   */
  hostnames?: string[];
  policies?: TCPFilterOrPolicy | null;
  backends?: LocalTCPRouteBackend[];
}
export interface TCPFilterOrPolicy {
  backendTLS?: LocalBackendTLS | null;
}
export interface LocalTCPBackendPolicies {
  /**
   * Send TLS to the backend.
   */
  backendTLS?: LocalBackendTLS | null;
}
export interface LocalGatewayPolicy {
  /**
   * Authenticate incoming JWT requests.
   */
  jwtAuth?: LocalJwtConfig | null;
  /**
   * Authenticate incoming requests by calling an external authorization server.
   */
  extAuthz?: ExtAuthz | null;
  /**
   * Extend agentgateway with an external processor
   */
  extProc?: ExtProc | null;
  /**
   * Modify requests and responses
   */
  transformations?: LocalTransformationConfig | null;
  /**
   * Authenticate incoming requests using Basic Authentication with htpasswd.
   */
  basicAuth?: LocalBasicAuth | null;
  /**
   * Authenticate incoming requests using API Keys
   */
  apiKey?: LocalAPIKeys | null;
}
export interface LocalFrontendPolicies {
  /**
   * Settings for handling incoming HTTP requests.
   */
  http?: HTTP2 | null;
  /**
   * Settings for handling incoming TLS connections.
   */
  tls?: TLS | null;
  /**
   * Settings for handling incoming TCP connections.
   */
  tcp?: TCP2 | null;
  /**
   * Settings for request access logs.
   */
  accessLog?: LoggingPolicy | null;
  tracing?: TracingConfig | null;
}
export interface HTTP2 {
  maxBufferSize?: number;
  /**
   * The maximum number of headers allowed in a request. Changing this value results in a performance
   * degradation, even if set to a lower value than the default (100)
   */
  http1MaxHeaders?: number | null;
  http1IdleTimeout?: string;
  http2WindowSize?: number | null;
  http2ConnectionWindowSize?: number | null;
  http2FrameSize?: number | null;
  http2KeepaliveInterval?: string | null;
  http2KeepaliveTimeout?: string | null;
}
export interface TLS {
  handshakeTimeout?: string;
  alpn?: number[][] | null;
  minVersion?: TLSVersion | null;
  maxVersion?: TLSVersion | null;
  cipherSuites?: string[] | null;
}
export interface TCP2 {
  keepalives: KeepaliveConfig1;
}
export interface LoggingPolicy {
  filter?: Expression | null;
  add?: {
    [k: string]: string;
  };
  remove?: string[];
}
/**
 * Span attributes to add, keyed by attribute name.
 */
export interface OrderedStringMap_Expression {
  [k: string]: Expression;
}
/**
 * Resource attributes to add to the tracer provider (OTel `Resource`).
 * This can be used to set things like `service.name` dynamically.
 */
export interface OrderedStringMap_Expression1 {
  [k: string]: Expression;
}
export interface LocalPolicy {
  name: ResourceName;
  target: PolicyTarget;
  /**
   * phase defines at what level the policy runs at. Gateway policies run pre-routing, while
   * Route policies apply post-routing.
   * Only a subset of policies are eligible as Gateway policies.
   * In general, normal (route level) policies should be used, except you need the policy to influence
   * routing.
   */
  phase?: "route" | "gateway";
  policy: FilterOrPolicy;
}
export interface ResourceName {
  name: string;
  namespace: string;
}
export interface ListenerTarget {
  gatewayName: string;
  gatewayNamespace: string;
  listenerName?: string | null;
}
export interface RouteName {
  name: string;
  namespace: string;
  ruleName?: string | null;
  kind?: string | null;
}
export interface FullLocalBackend {
  name: string;
  host: string;
  policies?: LocalBackendPolicies | null;
}
export interface LocalLLMConfig {
  /**
   * models defines the set of models that can be served by this gateway. The model name refers to the
   * model in the users request that is matched; the model sent to the actual LLM can be overridden
   * on a per-model basis.
   */
  models: LocalLLMModels[];
  /**
   * policies defines policies for handling incoming requests, before a model is selected
   */
  policies?: LocalLLMPolicy | null;
}
export interface LocalLLMModels {
  /**
   * name is the name of the model we are matching from a users request. If params.model is set, that
   * will be used in the request to the LLM provider. If not, the incoming model is used.
   */
  name: string;
  params?: LocalLLMParams;
  /**
   * provider of the LLM we are connecting too
   */
  provider: "openAI" | "gemini" | "vertex" | "anthropic" | "bedrock" | "azureOpenAI";
  /**
   * defaults allows setting default values for the request. If these are not present in the request body, they will be set.
   * To override even when set, use `overrides`.
   */
  defaults?: {
    [k: string]: unknown;
  } | null;
  /**
   * overrides allows setting values for the request, overriding any existing values
   */
  overrides?: {
    [k: string]: unknown;
  } | null;
  /**
   * requestHeaders modifies headers in requests to the LLM provider.
   */
  requestHeaders?: HeaderModifier | null;
  /**
   * guardrails to apply to the request or response
   */
  guardrails?: PromptGuard | null;
  /**
   * matches specifies the conditions under which this model should be used in addition to matching the model name.
   */
  matches?: LLMRouteMatch[];
}
/**
 * params customizes parameters for the outgoing request
 */
export interface LocalLLMParams {
  /**
   * The model to send to the provider.
   * If unset, the same model will be used from the request.
   */
  model?: string | null;
  /**
   * An API key to attach to the request.
   * If unset this will be automatically detected from the environment.
   */
  apiKey?: string | null;
  awsRegion?: string | null;
  vertexRegion?: string | null;
  vertexProject?: string | null;
  /**
   * For Azure: the host of the deployment
   */
  azureHost?: string | null;
  /**
   * For Azure: the API version to use
   */
  azureApiVersion?: string | null;
}
export interface LLMRouteMatch {
  headers?: HeaderMatch[];
}
export interface LocalLLMPolicy {
  /**
   * Authenticate incoming JWT requests.
   */
  jwtAuth?: LocalJwtConfig | null;
  /**
   * Authenticate incoming requests by calling an external authorization server.
   */
  extAuthz?: ExtAuthz | null;
  /**
   * Extend agentgateway with an external processor
   */
  extProc?: ExtProc | null;
  /**
   * Modify requests and responses
   */
  transformations?: LocalTransformationConfig | null;
  /**
   * Authenticate incoming requests using Basic Authentication with htpasswd.
   */
  basicAuth?: LocalBasicAuth | null;
  /**
   * Authenticate incoming requests using API Keys
   */
  apiKey?: LocalAPIKeys | null;
  /**
   * Authorization policies for HTTP access.
   */
  authorization?: RuleSet | null;
}
export interface LocalSimpleMcpConfig {
  port?: number;
  targets: LocalMcpTarget[];
  statefulMode?: McpStatefulMode;
  prefixMode?: McpPrefixMode | null;
  policies?: FilterOrPolicy | null;
}
